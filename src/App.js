import React, { useState, useEffect, useRef, useMemo } from 'react';
import { createClient } from '@supabase/supabase-js';
import { Radar, RadarChart, PolarGrid, PolarAngleAxis, PolarRadiusAxis, ResponsiveContainer, Legend, ScatterChart, Scatter, XAxis, YAxis, ZAxis, Tooltip, Cell, LineChart, Line, CartesianGrid } from 'recharts';
import { DndContext, closestCenter, PointerSensor, useSensor, useSensors } from '@dnd-kit/core';
import { SortableContext, verticalListSortingStrategy, useSortable, arrayMove } from '@dnd-kit/sortable';
import { CSS } from '@dnd-kit/utilities';

// Material-UI imports
import {
  Box, Container, Paper, Typography, Button, IconButton, TextField,
  Card, CardContent, Grid, Divider, Select, MenuItem, FormControl,
  InputLabel, Chip, Dialog, DialogTitle, DialogContent, DialogActions,
  Alert, Snackbar, List, ListItem, ListItemText, Accordion,
  AccordionSummary, AccordionDetails, Table, TableBody, TableCell,
  TableContainer, TableHead, TableRow, Fab, Tabs, Tab, Stack,
  Switch, FormControlLabel, ToggleButtonGroup, ToggleButton,
  Avatar, Badge, AppBar, Toolbar, Drawer
} from '@mui/material';

// Material Icons
import {
  ExpandMore as ExpandMoreIcon,
  CloudDownload as DownloadIcon,
  CloudUpload as UploadIcon,
  Save as SaveIcon,
  Wifi as WifiIcon,
  WifiOff as WifiOffIcon,
  History as HistoryIcon,
  CalendarToday as CalendarIcon,
  TrendingUp as TrendingUpIcon,
  People as PeopleIcon,
  Menu as MenuIcon,
  CompareArrows as CompareIcon,
  Keyboard as KeyboardIcon,
  Add as AddIcon,
  Delete as DeleteIcon,
  DragIndicator as DragIcon,
  Visibility as VisibilityIcon,
  VisibilityOff as VisibilityOffIcon
} from '@mui/icons-material';

const supabase = createClient(
  process.env.REACT_APP_SUPABASE_URL,
  process.env.REACT_APP_SUPABASE_ANON_KEY
);

// „Éà„Éº„Çπ„ÉàÈÄöÁü•
function ToastNotification({ toasts, removeToast }) {
  return (
    <>
      {toasts.map(toast => (
        <Snackbar
          key={toast.id}
          open={true}
          autoHideDuration={3000}
          onClose={() => removeToast(toast.id)}
          anchorOrigin={{ vertical: 'top', horizontal: 'right' }}
        >
          <Alert 
            onClose={() => removeToast(toast.id)} 
            severity={toast.type === 'success' ? 'success' : toast.type === 'error' ? 'error' : 'info'}
            variant="filled"
          >
            {toast.message}
          </Alert>
        </Snackbar>
      ))}
    </>
  );
}

// „Ç≠„Éº„Éú„Éº„Éâ„Ç∑„Éß„Éº„Éà„Ç´„ÉÉ„Éà„ÉÄ„Ç§„Ç¢„É≠„Ç∞
function KeyboardShortcutsDialog({ open, onClose }) {
  const shortcuts = [
    { key: 'Ctrl + S', description: '„Éá„Éº„Çø„Çí‰øùÂ≠ò' },
    { key: 'Ctrl + E', description: '„Éá„Éº„Çø„Çí„Ç®„ÇØ„Çπ„Éù„Éº„Éà' },
    { key: '1-5', description: '„Çø„ÉñÂàá„ÇäÊõø„Åà' },
    { key: 'Ctrl + M', description: '„É°„É≥„Éê„ÉºËøΩÂä†' },
    { key: 'Esc', description: '„É¢„Éº„ÉÄ„É´„ÇíÈñâ„Åò„Çã' },
    { key: '?', description: '„Åì„ÅÆ„Éò„É´„Éó„ÇíË°®Á§∫' }
  ];

  return (
    <Dialog open={open} onClose={onClose} maxWidth="sm" fullWidth>
      <DialogTitle>
        <Box display="flex" alignItems="center" gap={1}>
          <KeyboardIcon />
          „Ç≠„Éº„Éú„Éº„Éâ„Ç∑„Éß„Éº„Éà„Ç´„ÉÉ„Éà
        </Box>
      </DialogTitle>
      <DialogContent dividers>
        <List>
          {shortcuts.map((shortcut, idx) => (
            <ListItem key={idx}>
              <ListItemText 
                primary={shortcut.description}
                secondary={
                  <Chip label={shortcut.key} size="small" variant="outlined" sx={{ mt: 0.5 }} />
                }
              />
            </ListItem>
          ))}
        </List>
      </DialogContent>
      <DialogActions>
        <Button onClick={onClose}>Èñâ„Åò„Çã</Button>
      </DialogActions>
    </Dialog>
  );
}

// „Éâ„É©„ÉÉ„Ç∞ÂèØËÉΩ„Å™„É°„É≥„Éê„Éº„Ç´„Éº„Éâ
function SortableEmployeeCard({ emp, competencyNames, selectedEmployees, toggleEmployee, removeEmployee, handleScoreChange, handleEmployeeMemoChange, calculateAverage, getStrengthsAndWeaknesses, setEmployees }) {
  const {
    attributes,
    listeners,
    setNodeRef,
    transform,
    transition,
    isDragging
  } = useSortable({ id: emp.id });

  const style = {
    transform: CSS.Transform.toString(transform),
    transition,
    opacity: isDragging ? 0.5 : 1,
  };

  const { strengths, weaknesses } = getStrengthsAndWeaknesses(emp.scores);

  return (
    <Card ref={setNodeRef} style={style} sx={{ mb: 2 }} elevation={3}>
      <CardContent>
        <Box display="flex" alignItems="center" justifyContent="space-between" mb={2}>
          <Box display="flex" alignItems="center" gap={1} flex={1}>
            <IconButton {...attributes} {...listeners} size="small" sx={{ cursor: 'move' }}>
              <DragIcon />
            </IconButton>
            <IconButton
              size="small"
              onClick={() => {
                setEmployees(prev => prev.map(employee => 
                  employee.id === emp.id ? { ...employee, isExpanded: !employee.isExpanded } : employee
                ));
              }}
            >
              <ExpandMoreIcon 
                sx={{ 
                  transform: emp.isExpanded ? 'rotate(180deg)' : 'rotate(0deg)',
                  transition: 'transform 0.3s'
                }}
              />
            </IconButton>
            <Avatar sx={{ width: 32, height: 32, bgcolor: emp.color }} />
            <TextField
              value={emp.name}
              onChange={(e) => {
                setEmployees(prev => prev.map(employee => 
                  employee.id === emp.id ? { ...employee, name: e.target.value } : employee
                ));
              }}
              variant="standard"
              sx={{ flex: 1 }}
              InputProps={{ sx: { fontWeight: 'bold', fontSize: '1.1rem' } }}
            />
          </Box>

          <Stack direction="row" spacing={1}>
            <Button
              variant={selectedEmployees.includes(emp.id) ? "contained" : "outlined"}
              size="small"
              onClick={() => toggleEmployee(emp.id)}
              startIcon={selectedEmployees.includes(emp.id) ? <VisibilityIcon /> : <VisibilityOffIcon />}
            >
              {selectedEmployees.includes(emp.id) ? 'Ë°®Á§∫‰∏≠' : 'ÈùûË°®Á§∫'}
            </Button>
            <Button
              variant="contained"
              color="error"
              size="small"
              onClick={() => removeEmployee(emp.id)}
              startIcon={<DeleteIcon />}
            >
              ÂâäÈô§
            </Button>
          </Stack>
        </Box>

        <Stack direction="row" spacing={2} mb={2} flexWrap="wrap">
          <Paper elevation={0} sx={{ p: 2, bgcolor: 'grey.100', minWidth: 120 }}>
            <Typography variant="caption" color="text.secondary">Âπ≥Âùá„Çπ„Ç≥„Ç¢</Typography>
            <Typography variant="h5" fontWeight="bold">{calculateAverage(emp.scores)}</Typography>
          </Paper>
          
          <Box flex={1} minWidth={200}>
            <Typography variant="caption" color="success.main" fontWeight="bold" display="block">
              üí™ Âº∑„Åø: {strengths.map(s => s.name).join(', ')}
            </Typography>
            <Typography variant="caption" color="warning.main" fontWeight="bold" display="block">
              üìå Ë™≤È°å: {weaknesses.map(w => w.name).join(', ')}
            </Typography>
          </Box>
        </Stack>

        {emp.isExpanded && (
          <>
            <Grid container spacing={2}>
              {Object.entries(competencyNames).map(([key, name]) => (
                <Grid item xs={12} sm={6} key={key}>
                  <FormControl fullWidth size="small">
                    <InputLabel>{name}</InputLabel>
                    <Select
                      value={emp.scores[key]}
                      label={name}
                      onChange={(e) => handleScoreChange(emp.id, key, e.target.value)}
                    >
                      {[1, 2, 3, 4, 5].map(level => (
                        <MenuItem key={level} value={level}>Lv.{level}</MenuItem>
                      ))}
                    </Select>
                  </FormControl>
                </Grid>
              ))}
            </Grid>

            <Divider sx={{ my: 2 }} />

            <TextField
              fullWidth
              multiline
              rows={3}
              label="üìù „É°„É¢"
              value={emp.memo || ""}
              onChange={(e) => handleEmployeeMemoChange(emp.id, e.target.value)}
              placeholder="ËÇ≤ÊàêË™≤È°å„ÄÅÁõÆÊ®ô„ÄÅÁâπË®ò‰∫ãÈ†Ö„Å™„Å©„ÇíË®òÂÖ•..."
              variant="outlined"
            />
          </>
        )}
      </CardContent>
    </Card>
  );
}

function App() {
  const sensors = useSensors(
    useSensor(PointerSensor, {
      activationConstraint: { distance: 8 },
    })
  );

  const handleDragEnd = (event) => {
    const { active, over } = event;
    if (over && active.id !== over.id) {
      setEmployees((items) => {
        const oldIndex = items.findIndex((item) => item.id === active.id);
        const newIndex = items.findIndex((item) => item.id === over.id);
        return arrayMove(items, oldIndex, newIndex);
      });
    }
  };

  const [employees, setEmployees] = useState([
    {
      id: 1, name: "Â±±Áî∞Â§™ÈÉé", color: "#2196f3", memo: "", isExpanded: true,
      scores: { dataAnalysis: 3, hypothesis: 3, questioning: 2, businessUnderstanding: 3, problemFinding: 2, problemSolving: 3, financial: 2, strategy: 3, communication: 4, support: 3 }
    },
    {
      id: 2, name: "‰ΩêËó§Ëä±Â≠ê", color: "#ec4899", memo: "", isExpanded: true,
      scores: { dataAnalysis: 2, hypothesis: 2, questioning: 3, businessUnderstanding: 2, problemFinding: 3, problemSolving: 2, financial: 2, strategy: 2, communication: 4, support: 4 }
    }
  ]);

  const [selectedEmployees, setSelectedEmployees] = useState([1, 2]);
  const [showIdeal, setShowIdeal] = useState(true);
  const [chartType, setChartType] = useState('radar');
  const [idealProfile, setIdealProfile] = useState({
    memo: "", isExpanded: true,
    dataAnalysis: 5, hypothesis: 5, questioning: 5, businessUnderstanding: 5,
    problemFinding: 5, problemSolving: 5, financial: 5, strategy: 5, communication: 5, support: 5
  });
  const [lastSaved, setLastSaved] = useState(null);
  const [teamMemo, setTeamMemo] = useState("");
  const [isOnline, setIsOnline] = useState(true);
  const [isSaving, setIsSaving] = useState(false);
  const [viewMode, setViewMode] = useState(0);
  const [evaluationHistory, setEvaluationHistory] = useState([]);
  const [newEvaluationDate, setNewEvaluationDate] = useState('');
  const [newEvaluationMemo, setNewEvaluationMemo] = useState('');
  const [toasts, setToasts] = useState([]);
  const [hasUnsavedChanges, setHasUnsavedChanges] = useState(false);
  const [showKeyboardHelp, setShowKeyboardHelp] = useState(false);
  const [compareHistory1, setCompareHistory1] = useState('');
  const [compareHistory2, setCompareHistory2] = useState('');
  const [expandedCriteria, setExpandedCriteria] = useState({});

  const competencyNames = {
    dataAnalysis: "„Éá„Éº„ÇøÂàÜÊûêÂäõ", hypothesis: "‰ªÆË™¨ÊÄùËÄÉÂäõ", questioning: "Ë≥™ÂïèÂäõ„Éª„Éí„Ç¢„É™„É≥„Ç∞Âäõ",
    businessUnderstanding: "‰∫ãÊ•≠ÁêÜËß£Âäõ", problemFinding: "Ë™≤È°åÁô∫Ë¶ãÂäõ", problemSolving: "ÂïèÈ°åËß£Ê±∫Âäõ",
    financial: "Ë≤°ÂãôÁêÜËß£Âäõ", strategy: "Êà¶Áï•Á´ãÊ°àÂäõ", communication: "„Ç≥„Éü„É•„Éã„Ç±„Éº„Ç∑„Éß„É≥Âäõ", support: "‰º¥Ëµ∞ÊîØÊè¥Âäõ"
  };

  const addToast = (message, type = 'info') => {
    const id = Date.now();
    setToasts(prev => [...prev, { id, message, type }]);
  };

  const removeToast = (id) => {
    setToasts(prev => prev.filter(toast => toast.id !== id));
  };

  const calculateAverage = (scores) => {
    const { memo, isExpanded, ...actualScores } = scores;
    const values = Object.values(actualScores);
    return (values.reduce((a, b) => a + b, 0) / values.length).toFixed(1);
  };

  const getStrengthsAndWeaknesses = (scores) => {
    const entries = Object.entries(scores)
      .filter(([key]) => competencyNames[key])
      .map(([key, value]) => ({
        name: competencyNames[key], score: value
      }));
    const sorted = [...entries].sort((a, b) => b.score - a.score);
    return { strengths: sorted.slice(0, 3), weaknesses: sorted.slice(-3).reverse() };
  };

  const addEmployee = () => {
    const newId = Math.max(...employees.map(e => e.id), 0) + 1;
    const colors = ["#8b5cf6", "#10b981", "#f59e0b", "#ef4444", "#06b6d4", "#f97316", "#14b8a6"];
    const availableColor = colors.find(c => !employees.map(e => e.color).includes(c)) || colors[0];
    
    setEmployees(prev => [...prev, {
      id: newId, name: `„É°„É≥„Éê„Éº${newId}`, color: availableColor, memo: "", isExpanded: true,
      scores: { dataAnalysis: 1, hypothesis: 1, questioning: 1, businessUnderstanding: 1, problemFinding: 1, problemSolving: 1, financial: 1, strategy: 1, communication: 1, support: 1 }
    }]);
    setSelectedEmployees(prev => [...prev, newId]);
    addToast('„É°„É≥„Éê„Éº„ÇíËøΩÂä†„Åó„Åæ„Åó„Åü', 'success');
  };

  const removeEmployee = (id) => {
    if (employees.length <= 1) {
      addToast('ÊúÄ‰Ωé1‰∫∫„ÅÆ„É°„É≥„Éê„Éº„ÅåÂøÖË¶Å„Åß„Åô', 'error');
      return;
    }
    setEmployees(prev => prev.filter(emp => emp.id !== id));
    setSelectedEmployees(prev => prev.filter(empId => empId !== id));
    addToast('„É°„É≥„Éê„Éº„ÇíÂâäÈô§„Åó„Åæ„Åó„Åü', 'success');
  };

  const toggleEmployee = (id) => {
    setSelectedEmployees(prev => 
      prev.includes(id) ? prev.filter(empId => empId !== id) : [...prev, id]
    );
  };

  const handleScoreChange = (employeeId, competency, value) => {
    setEmployees(prev => prev.map(emp => 
      emp.id === employeeId 
        ? { ...emp, scores: { ...emp.scores, [competency]: parseInt(value) } }
        : emp
    ));
  };

  const handleEmployeeMemoChange = (employeeId, value) => {
    setEmployees(prev => prev.map(emp => 
      emp.id === employeeId ? { ...emp, memo: value } : emp
    ));
  };

  const prepareChartData = () => {
    const data = Object.keys(competencyNames).map(key => {
      const item = { competency: competencyNames[key] };
      if (showIdeal) item['ÁêÜÊÉ≥'] = idealProfile[key];
      employees.forEach(emp => {
        if (selectedEmployees.includes(emp.id)) item[emp.name] = emp.scores[key];
      });
      return item;
    });
    return data;
  };

  const exportData = () => {
    const dataToExport = {
      employees, idealProfile, selectedEmployees, showIdeal,
      exportedAt: new Date().toISOString()
    };
    const blob = new Blob([JSON.stringify(dataToExport, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `ps-evaluation-${new Date().toISOString().split('T')[0]}.json`;
    a.click();
    URL.revokeObjectURL(url);
    addToast('„Éá„Éº„Çø„Çí„Ç®„ÇØ„Çπ„Éù„Éº„Éà„Åó„Åæ„Åó„Åü', 'success');
  };

  const saveToSupabase = async () => {
    setIsSaving(true);
    addToast('‰øùÂ≠ò„Åó„Åæ„Åó„Åü', 'success');
    setHasUnsavedChanges(false);
    setIsSaving(false);
  };

  // „Ç≠„Éº„Éú„Éº„Éâ„Ç∑„Éß„Éº„Éà„Ç´„ÉÉ„Éà
  useEffect(() => {
    const handleKeyDown = (e) => {
      if ((e.ctrlKey || e.metaKey) && e.key === 's') {
        e.preventDefault();
        saveToSupabase();
      }
      if ((e.ctrlKey || e.metaKey) && e.key === 'e') {
        e.preventDefault();
        exportData();
      }
      if ((e.ctrlKey || e.metaKey) && e.key === 'm') {
        e.preventDefault();
        addEmployee();
      }
      if (!e.ctrlKey && !e.metaKey && !e.altKey) {
        if (e.key === '1') setViewMode(0);
        if (e.key === '2') setViewMode(1);
        if (e.key === '3') setViewMode(2);
        if (e.key === '4') setViewMode(3);
        if (e.key === '5') setViewMode(4);
      }
      if (e.key === '?') {
        e.preventDefault();
        setShowKeyboardHelp(true);
      }
      if (e.key === 'Escape') {
        setShowKeyboardHelp(false);
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, []);

  return (
    <Box sx={{ bgcolor: 'grey.50', minHeight: '100vh', pb: { xs: 10, md: 4 } }}>
      <ToastNotification toasts={toasts} removeToast={removeToast} />
      <KeyboardShortcutsDialog open={showKeyboardHelp} onClose={() => setShowKeyboardHelp(false)} />

      <AppBar position="static" elevation={1} sx={{ bgcolor: 'primary.main' }}>
        <Toolbar>
          <Typography variant="h6" component="div" sx={{ flexGrow: 1, fontWeight: 'bold' }}>
            PSËÉΩÂäõË©ï‰æ°„ÉÅ„É£„Éº„Éà
          </Typography>
          <IconButton color="inherit" onClick={() => setShowKeyboardHelp(true)} sx={{ mr: 1 }}>
            <KeyboardIcon />
          </IconButton>
          <Chip
            icon={isOnline ? <WifiIcon /> : <WifiOffIcon />}
            label={hasUnsavedChanges ? 'Êú™‰øùÂ≠ò' : '„Ç™„É≥„É©„Ç§„É≥'}
            color={isOnline ? 'success' : 'error'}
            size="small"
            sx={{ mr: 2, color: 'white', borderColor: 'white' }}
            variant="outlined"
          />
          <Button
            variant="contained"
            color="success"
            startIcon={<SaveIcon />}
            onClick={saveToSupabase}
            disabled={isSaving}
            sx={{ boxShadow: 2 }}
          >
            ‰øùÂ≠ò
          </Button>
        </Toolbar>
      </AppBar>

      <Container maxWidth="xl" sx={{ mt: 3 }}>
        <Paper sx={{ p: { xs: 2, md: 3 }, mb: 3 }} elevation={2}>
          <Typography variant="h4" gutterBottom fontWeight="bold" color="primary">
            PSËÉΩÂäõË©ï‰æ°„ÉÅ„É£„Éº„Éà
          </Typography>
          <Typography variant="body1" color="text.secondary" paragraph>
            10„ÅÆËÉΩÂäõ„Çí5ÊÆµÈöé„ÅßË©ï‰æ°„Åó„ÄÅË¶ñË¶öÁöÑ„Å´Âº∑„Åø„ÉªÂº±„Åø„ÇíÊääÊè°„Åô„Çã
          </Typography>

          {lastSaved && (
            <Typography variant="caption" color="text.secondary" display="block" mb={2}>
              ÊúÄÁµÇ‰øùÂ≠ò: {lastSaved.toLocaleString('ja-JP')}
              {hasUnsavedChanges && (
                <Chip label="Êú™‰øùÂ≠ò„ÅÆÂ§âÊõ¥„ÅÇ„Çä" size="small" color="warning" sx={{ ml: 1 }} />
              )}
            </Typography>
          )}

          <Alert severity="info" sx={{ mb: 3 }} icon="üí°">
            <Typography variant="body2">
              <strong>„Éí„É≥„Éà:</strong> <Chip label="?" size="small" variant="outlined" sx={{ mx: 0.5 }} /> „Ç≠„Éº„Åß„Ç∑„Éß„Éº„Éà„Ç´„ÉÉ„Éà‰∏ÄË¶ß„ÇíË°®Á§∫
            </Typography>
          </Alert>

          <Box sx={{ borderBottom: 1, borderColor: 'divider', mb: 3 }}>
            <Tabs value={viewMode} onChange={(e, v) => setViewMode(v)} variant="scrollable" scrollButtons="auto">
              <Tab icon={<CalendarIcon />} label="ÁèæÂú®„ÅÆË©ï‰æ°" iconPosition="start" />
              <Tab icon={<HistoryIcon />} label="ÊàêÈï∑Â±•Ê≠¥" iconPosition="start" />
              <Tab icon={<CompareIcon />} label="Â±•Ê≠¥ÊØîËºÉ" iconPosition="start" />
              <Tab icon={<TrendingUpIcon />} label="ÊôÇÁ≥ªÂàóÊØîËºÉ" iconPosition="start" />
              <Tab icon={<PeopleIcon />} label="„ÉÅ„Éº„É†ÂàÜÊûê" iconPosition="start" />
            </Tabs>
          </Box>

          <Stack direction={{ xs: 'column', sm: 'row' }} spacing={2} alignItems={{ xs: 'stretch', sm: 'center' }} mb={2}>
            <Button 
              variant="contained" 
              startIcon={<AddIcon />} 
              onClick={addEmployee}
              size="large"
            >
              „É°„É≥„Éê„ÉºËøΩÂä†
            </Button>
            
            <FormControlLabel
              control={<Switch checked={showIdeal} onChange={(e) => setShowIdeal(e.target.checked)} color="primary" />}
              label="ÁêÜÊÉ≥ÂΩ¢„ÇíË°®Á§∫"
            />

            <Box sx={{ ml: { sm: 'auto' } }}>
              <ToggleButtonGroup
                value={chartType}
                exclusive
                onChange={(e, v) => v && setChartType(v)}
                size="small"
                color="primary"
              >
                <ToggleButton value="radar">üìä „É¨„Éº„ÉÄ„Éº</ToggleButton>
                <ToggleButton value="scatter">üìà „Éû„Éà„É™„ÇØ„Çπ</ToggleButton>
              </ToggleButtonGroup>
            </Box>

            <Stack direction="row" spacing={1} sx={{ display: { xs: 'flex', md: 'flex' } }}>
              <Button
                variant="outlined"
                startIcon={<DownloadIcon />}
                onClick={exportData}
                size="small"
              >
                JSON
              </Button>
            </Stack>
          </Stack>
        </Paper>

        {viewMode === 0 && (
          <Grid container spacing={3}>
            <Grid item xs={12} lg={6}>
              <Paper sx={{ p: 3, height: '100%' }} elevation={3}>
                <Alert severity="info" sx={{ mb: 3 }}>
                  <Typography variant="body2" fontWeight="bold" gutterBottom>
                    üíæ Ë©ï‰æ°„ÇíÂ±•Ê≠¥„Å®„Åó„Å¶‰øùÂ≠ò
                  </Typography>
                  <Stack direction={{ xs: 'column', sm: 'row' }} spacing={2} mt={2}>
                    <TextField
                      type="date"
                      label="Ë©ï‰æ°Êó•"
                      value={newEvaluationDate}
                      onChange={(e) => setNewEvaluationDate(e.target.value)}
                      size="small"
                      fullWidth
                      InputLabelProps={{ shrink: true }}
                    />
                    <TextField
                      label="„É°„É¢Ôºà‰ªªÊÑèÔºâ"
                      value={newEvaluationMemo}
                      onChange={(e) => setNewEvaluationMemo(e.target.value)}
                      placeholder="‰æã: Q1Ë©ï‰æ°"
                      size="small"
                      fullWidth
                    />
                    <Button
                      variant="contained"
                      onClick={() => addToast('Â±•Ê≠¥„Å´‰øùÂ≠ò„Åó„Åæ„Åó„Åü', 'success')}
                      sx={{ minWidth: 120 }}
                    >
                      Â±•Ê≠¥„Å´‰øùÂ≠ò
                    </Button>
                  </Stack>
                </Alert>

                <Typography variant="h6" gutterBottom fontWeight="bold">
                  {chartType === 'radar' ? 'üìä ËÉΩÂäõ„É¨„Éº„ÉÄ„Éº„ÉÅ„É£„Éº„Éà' : 'üìà ËÉΩÂäõ„Éû„Éà„É™„ÇØ„ÇπË°®'}
                </Typography>
                
                <Box sx={{ width: '100%', height: 450, mt: 2 }}>
                  <ResponsiveContainer width="100%" height="100%">
                    <RadarChart data={prepareChartData()}>
                      <PolarGrid stroke="#cbd5e1" />
                      <PolarAngleAxis 
                        dataKey="competency" 
                        tick={{ fill: '#475569', fontSize: 11 }} 
                      />
                      <PolarRadiusAxis 
                        angle={90} 
                        domain={[0, 5]} 
                        tick={{ fill: '#64748b' }} 
                        tickCount={6} 
                      />
                      {showIdeal && (
                        <Radar 
                          name="ÁêÜÊÉ≥" 
                          dataKey="ÁêÜÊÉ≥" 
                          stroke="#94a3b8" 
                          fill="#94a3b8" 
                          fillOpacity={0.1} 
                          strokeWidth={2} 
                          strokeDasharray="5 5" 
                        />
                      )}
                      {employees
                        .filter(emp => selectedEmployees.includes(emp.id))
                        .map(emp => (
                          <Radar 
                            key={emp.id} 
                            name={emp.name} 
                            dataKey={emp.name} 
                            stroke={emp.color} 
                            fill={emp.color} 
                            fillOpacity={0.3} 
                            strokeWidth={2} 
                          />
                        ))}
                      <Legend />
                    </RadarChart>
                  </ResponsiveContainer>
                </Box>

                <Divider sx={{ my: 3 }} />

                <Typography variant="h6" gutterBottom fontWeight="bold">
                  üìù „ÉÅ„Éº„É†ÂÖ®‰Ωì„ÅÆ„É°„É¢
                </Typography>
                <TextField
                  fullWidth
                  multiline
                  rows={6}
                  value={teamMemo}
                  onChange={(e) => setTeamMemo(e.target.value)}
                  placeholder="‰æãÔºö‰ªäÊúü„ÅÆË©ï‰æ°ÊñπÈáù„ÄÅÂÖ®‰ΩìÁöÑ„Å™ÂÇæÂêë„ÄÅÊ¨°Âõû„ÅÆË¶ãÁõ¥„Åó„Éù„Ç§„É≥„Éà„Å™„Å©..."
                  variant="outlined"
                />
              </Paper>
            </Grid>

            <Grid item xs={12} lg={6}>
              {showIdeal && (
                <Card sx={{ mb: 2, bgcolor: 'grey.100' }} elevation={3}>
                  <CardContent>
                    <Box display="flex" alignItems="center" gap={2} mb={2}>
                      <IconButton
                        size="small"
                        onClick={() => setIdealProfile(prev => ({ ...prev, isExpanded: !prev.isExpanded }))}
                      >
                        <ExpandMoreIcon 
                          sx={{ 
                            transform: idealProfile.isExpanded ? 'rotate(180deg)' : 'rotate(0deg)',
                            transition: 'transform 0.3s'
                          }}
                        />
                      </IconButton>
                      <Avatar sx={{ bgcolor: 'grey.400' }} />
                      <Typography variant="h6" fontWeight="bold">
                        ÁêÜÊÉ≥ÂΩ¢ÔºàÁõÆÊ®ô„É¨„Éô„É´Ôºâ
                      </Typography>
                    </Box>

                    <Paper elevation={0} sx={{ p: 2, bgcolor: 'white', display: 'inline-block' }}>
                      <Typography variant="caption" color="text.secondary">Âπ≥Âùá„Çπ„Ç≥„Ç¢</Typography>
                      <Typography variant="h5" fontWeight="bold">{calculateAverage(idealProfile)}</Typography>
                    </Paper>

                    {idealProfile.isExpanded && (
                      <>
                        <Grid container spacing={2} sx={{ mt: 1 }}>
                          {Object.entries(competencyNames).map(([key, name]) => (
                            <Grid item xs={12} sm={6} key={key}>
                              <FormControl fullWidth size="small">
                                <InputLabel>{name}</InputLabel>
                                <Select
                                  value={idealProfile[key]}
                                  label={name}
                                  onChange={(e) => setIdealProfile(prev => ({ ...prev, [key]: parseInt(e.target.value) }))}
                                >
                                  {[1, 2, 3, 4, 5].map(level => (
                                    <MenuItem key={level} value={level}>Lv.{level}</MenuItem>
                                  ))}
                                </Select>
                              </FormControl>
                            </Grid>
                          ))}
                        </Grid>

                        <Divider sx={{ my: 2 }} />

                        <TextField
                          fullWidth
                          multiline
                          rows={3}
                          label="üìù „É°„É¢"
                          value={idealProfile.memo || ""}
                          onChange={(e) => setIdealProfile(prev => ({ ...prev, memo: e.target.value }))}
                          placeholder="ÁõÆÊ®ôË®≠ÂÆö„ÅÆÁêÜÁî±„ÇÑÈÅîÊàêÊôÇÊúü"
                        />
                      </>
                    )}
                  </CardContent>
                </Card>
              )}

              <DndContext sensors={sensors} collisionDetection={closestCenter} onDragEnd={handleDragEnd}>
                <SortableContext items={employees.map(emp => emp.id)} strategy={verticalListSortingStrategy}>
                  {employees.map(emp => (
                    <SortableEmployeeCard
                      key={emp.id}
                      emp={emp}
                      competencyNames={competencyNames}
                      selectedEmployees={selectedEmployees}
                      toggleEmployee={toggleEmployee}
                      removeEmployee={removeEmployee}
                      handleScoreChange={handleScoreChange}
                      handleEmployeeMemoChange={handleEmployeeMemoChange}
                      calculateAverage={calculateAverage}
                      getStrengthsAndWeaknesses={getStrengthsAndWeaknesses}
                      setEmployees={setEmployees}
                    />
                  ))}
                </SortableContext>
              </DndContext>
            </Grid>
          </Grid>
        )}

        {viewMode === 4 && (
          <Paper sx={{ p: 3 }} elevation={2}>
            <Typography variant="h5" gutterBottom fontWeight="bold">
              üìä „ÉÅ„Éº„É†ÂÖ®‰Ωì„ÅÆÂàÜÊûê
            </Typography>
            
            <Grid container spacing={2} mb={4}>
              <Grid item xs={12} md={4}>
                <Card sx={{ bgcolor: 'primary.light', color: 'white', height: '100%' }} elevation={4}>
                  <CardContent>
                    <Typography variant="subtitle2" gutterBottom>„ÉÅ„Éº„É†Âπ≥Âùá„Çπ„Ç≥„Ç¢</Typography>
                    <Typography variant="h3" fontWeight="bold">
                      {(() => {
                        const allAverages = employees.map(emp => parseFloat(calculateAverage(emp.scores)));
                        return (allAverages.reduce((a, b) => a + b, 0) / allAverages.length).toFixed(1);
                      })()}
                    </Typography>
                  </CardContent>
                </Card>
              </Grid>

              <Grid item xs={12} md={4}>
                <Card sx={{ bgcolor: 'success.light', color: 'white', height: '100%' }} elevation={4}>
                  <CardContent>
                    <Typography variant="subtitle2" gutterBottom>ÊúÄÈ´ò„Çπ„Ç≥„Ç¢‰øùÊåÅËÄÖ</Typography>
                    <Typography variant="h4" fontWeight="bold">
                      {(() => {
                        const sorted = [...employees].sort((a, b) => 
                          parseFloat(calculateAverage(b.scores)) - parseFloat(calculateAverage(a.scores))
                        );
                        return sorted[0]?.name || '-';
                      })()}
                    </Typography>
                  </CardContent>
                </Card>
              </Grid>

              <Grid item xs={12} md={4}>
                <Card sx={{ bgcolor: 'warning.light', color: 'white', height: '100%' }} elevation={4}>
                  <CardContent>
                    <Typography variant="subtitle2" gutterBottom>Ë©ï‰æ°ÂÆüÊñΩÂõûÊï∞</Typography>
                    <Typography variant="h3" fontWeight="bold">
                      {evaluationHistory.length + 1}Âõû
                    </Typography>
                  </CardContent>
                </Card>
              </Grid>
            </Grid>
          </Paper>
        )}
      </Container>

      {/* „É¢„Éê„Ç§„É´Áî®„Éï„É≠„Éº„ÉÜ„Ç£„É≥„Ç∞„Éú„Çø„É≥ */}
      <Fab
        color="primary"
        sx={{ 
          position: 'fixed', 
          bottom: { xs: 70, md: 16 }, 
          right: 16,
          display: { xs: 'flex', md: 'none' }
        }}
        onClick={addEmployee}
      >
        <AddIcon />
      </Fab>

      {/* „É¢„Éê„Ç§„É´Áî®‰øùÂ≠ò„Éú„Çø„É≥ */}
      <Paper
        elevation={8}
        sx={{
          position: 'fixed',
          bottom: 0,
          left: 0,
          right: 0,
          p: 2,
          display: { xs: 'block', md: 'none' },
          zIndex: 1000
        }}
      >
        <Button
          fullWidth
          variant="contained"
          color="success"
          size="large"
          startIcon={<SaveIcon />}
          onClick={saveToSupabase}
          disabled={isSaving}
        >
          {isSaving ? '‰øùÂ≠ò‰∏≠...' : hasUnsavedChanges ? '‰øùÂ≠ò„Åô„ÇãÔºàÊú™‰øùÂ≠òÔºâ' : '‰øùÂ≠òÊ∏à„Åø'}
        </Button>
      </Paper>
    </Box>
  );
}

export default App;